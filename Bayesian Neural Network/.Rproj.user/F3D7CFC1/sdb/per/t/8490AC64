{
    "collab_server" : "",
    "contents" : "require(rjags)\nrequire(coda)\nrequire(neuralnet)\n\n# model neal for BNN ------------------------------------------------------\n\n\n#Dataset creation\nN=1000     # number of observations\nP=5       # number of covariates\nK = 20    # number of neurons in the hidden layer\n\n# X <- matrix(runif(N*P), c(N,P))\n# Y <- (X[,1]^2 + log(X[,2]) + 3^X[,3]+ X[,4]*X[,5])# + c(rnorm(100))\n# dat <- data.frame(cbind(X,Y))\n#save(file = 'data_simmulated_for_neal.RData', dat, X,Y)\n\n# load data\n#load(file = 'data_simmulate.RData')\nload('data_simmulated_for_neal.RData')\n# fitting normal NN\n#K=18\nK=15\nf <- as.formula(paste(\"Y~\" , paste(names(dat)[!names(dat)=='Y'], collapse = '+')))\nnet.1 <- neuralnet(f, data = dat, hidden = K , linear.output = T,\n                   lifesign = 'full', threshold = 0.1)\n\nsave(net.1, file = 'network_for_K_15_1000.RData')\nZ <- compute_Z_matrix(net.1$weights[[1]][[1]],X)\n\nY.hat <- Z%*%net.1$weights[[1]][[2]]\nplot(net.1$net.result[[1]],-32 -Y.hat)\n\nplot(net.1$net.result[[1]], Y)\nsum((net.1$net.result[[1]]- Y)^2)/42\n\n\n# Jags model compile\njags3 <- jags.model('neal2.bug', data = list('X'=X, 'y'=Y, 'K'=K, 'R'=5, 'N'=N,\n                                           'alpha'= alpha.2/2, 'beta'= alpha.2/2/omega.y,\n                                           'alpha.o'= alpha.0/2, 'beta.o'= alpha.0/2/omega.0,\n                                           'alpha.b'= alpha.b/2, 'beta.b'= alpha.b/2/omega.b,\n                                             'alpha.a'= alpha.a/2, 'beta.a'= alpha.a/2/omega.a,\n                                           'alpha.out.1'= alpha.1/2, 'alpha.in.1'= alpha.1/2),\n                    inits = list('Gamma.0' = net.1$weights[[1]][[1]][1,], 'Gamma'=t(net.1$weights[[1]][[1]][-1,]),\n                                 'Beta'= net.1$weights[[1]][[2]][-1], 'Beta.0'= net.1$weights[[1]][[2]][1]),\n                   n.adapt = 1000)\n\n\nupdate(jags3, 100)\n\nsim_neal_huge <- jags.samples(jags3,variable.names = c('Gamma', 'Beta',\n                                                 'Gamma.0','Beta.0',\n                                                 'tau', 'Y.rep','p.log'),100000)\n\nsave(sim_neal_huge, file = 'neal_chain_huge_chain.RData')\n\nload('neal_chain2.RData')\nload('neal_chain3_for_15nuerons.RData')\nload('neal_chain4_for_15nuerons.RData')\nload('neal_chain_huge_chain.RData')\n\n# visualizing distribution ------------------------------------------------\n\nsim <- sim_neal_huge\n\nfor(k in 1:K){\n  plot_and_find_the_mode(sim$Gamma.0,k, obj='Gamma.0')\n  Sys.sleep(1.5)\n  for(p in 1:P){\n    plot_and_find_the_mode(sim$Gamma,k,p, obj='Gamma')\n    Sys.sleep(1.5)\n  }\n}\n\nplot_and_find_the_mode(sim_neal2$Beta.0, obj = 'Beta.0')\nfor(k in 1:K){\n  plot_and_find_the_mode(sim_neal2$Beta,k, obj = 'Beta')\n  Sys.sleep(1.5)\n}\n\nfor(i in 1:10){\n  plot(density(sim_neal2$Y.rep[i,,1]))\n  points(Y[i],0,col='blue')\n  p <- mean(sim_neal2$Y.rep[i,,1]< Y[i])\n  p_val <- min(p, 1-p)\n  print(p_val)\n  Sys.sleep(0.7)\n}\n\n# Traceplots\n\nts.plot(sim$Beta[1,,])\nts.plot(sim$Beta.0[1,,])\nts.plot(sim$Beta[2,,])\nts.plot(sim$Gamma[1,1,,])\n\n# running mean\n\nsim1 <- sim$Beta[1,,]\nsim1 <- sim$Beta.0[1,,]\nsim1 <- sim$Beta[2,,]\nsim1 <- sim$Gamma[1,1,,]\n\nts.plot(cumsum(sim1)/seq_along(sim1))\n\n# Make predictions\n\ny.hat.mode.2 <- prediction_for_neal_BNN(X,sim = sim)\ny.hat.mean.2 <- prediction_for_neal_BNN_with_mean(X,sim)\n\nplot(Y,y.hat,xlim = c(-4,5),ylim = c(0,4))\nplot(Y,y.hat.mean.2)\nplot(Y,y.hat.mode.2)\n\n# # analisys of goodness-of-fit\n# Y.rep <- replicated_from_posterior_predictive(X, sim_neal2)\n# save(Y.rep, file = 'Y_replicated_from_neal_priors.RData')\n\n# function used -----------------------------------------------------------\n\nplot_and_find_the_mode <- function(sim, i =0, j=0, obj=''){\n  if(i == 0){\n    den <- density(sim[,,1])\n  }else if(j==0){\n    den <- density(sim[i,,1])\n  }else{\n    den <- density(sim[i,j,,1])\n  }\n  massimo <- den$x[which.max(den$y)]\n  if(obj=='Beta'){\n    lim <- net.1$weights[[1]][[2]][i,1]\n    plot(den, xlim=c(-abs(lim)-2,+ abs(lim)+2), main = paste('Beta',i) )\n    segments(massimo,0,y1=max(den$y), col='grey')\n    points(lim ,0, col='blue')\n  }\n  if(obj=='Beta.0'){\n    lim <- net.1$weights[[1]][[2]][(K+1),1]\n    plot(den, xlim=c(-abs(lim)-2,+ abs(lim)+2), main ='Beta0')\n    segments(massimo,0,y1=max(den$y), col='grey')\n    points(lim,0, col='blue')\n  }\n  if(obj=='Gamma'){\n    lim <- net.1$weights[[1]][[1]][j,i]\n    plot(den, xlim=c(-abs(lim)-2,+ abs(lim)+2),main = paste(paste('Gamma- neuron: ',i),\n                                                           paste(' -covariate: ', j)) )\n    segments(massimo,0,y1=max(den$y), col='grey')\n    points(lim,0, col='blue')\n  }\n  if(obj=='Gamma.0'){\n    lim <- net.1$weights[[1]][[1]][6,i]\n    plot(den, xlim=c(-abs(lim)-2,+ abs(lim)+2), main = paste('Gamma.0 Bias - neuron: ',i))\n    segments(massimo,0,y1=max(den$y), col='grey')\n    points(lim,0, col='blue')\n  }\n  return(massimo)\n}\n\nfind_maximum <- function(sim, i = 0, j=0){\n  if(i == 0){\n    den <- density(sim[,,1])\n  }else if(j==0){\n    den <- density(sim[i,,1])\n  }else{\n    den <- density(sim[i,j,,1])\n  }\n  massimo <- den$x[which.max(den$y)]\n  return(massimo)\n}\n\nprediction_for_neal_BNN <- function(X,sim){\n  bias.beta <- find_maximum(sim_neal$Beta.0)\n  betas <- rep(NA,20)\n  for(n in 1:20){\n    betas[n]<- find_maximum(sim_neal$Beta,i=n)\n  }\n  bias.gammas <- rep(NA,20)\n  gammas <- matrix(rep(NA,20*5),c(20,5))\n  for(n in 1:20){\n    bias.gammas[n] <- find_maximum(sim_neal$Gamma.0,i=n)\n    for(p in 1:5){\n      gammas[n,p]<- find_maximum(sim_neal$Gamma,i = n,j = p)\n    }\n  }\n  N <- dim(X)[1]\n  y.hat <- rep(NA,N)\n  Z <- matrix(rep(NA,N*20),c(N,20))\n  Z.np <- matrix(rep(NA,N*20),c(N,20))\n  for(i in 1:N){\n    for(j in 1:20){\n      Z[ i, j] <- bias.gammas[ j ] +  X[i,]%*%gammas[j,]\n      #print(Z[ i, j])\n      Z.np[i,j] <-  (1) / (1+ exp(- Z[i,j]))\n    }\n    y.hat[i] <- bias.beta +Z.np[i,]%*%betas\n  }\n  return(y.hat)\n}\n\nprediction_for_neal_BNN_with_mean <- function(X,sim){\n  bias.beta <- mean(sim_neal$Beta.0)\n  betas <- rep(NA,20)\n  for(n in 1:20){\n    betas[n]<- mean(sim_neal$Beta[n,,1])\n  }\n  bias.gammas <- rep(NA,20)\n  gammas <- matrix(rep(NA,20*5),c(20,5))\n  for(n in 1:20){\n    bias.gammas[n] <- mean(sim_neal$Gamma.0[n,,1])\n    for(p in 1:5){\n      gammas[n,p]<- mean(sim_neal$Gamma[n,p,,1])\n    }\n  }\n  N <- dim(X)[1]\n  y.hat <- rep(NA,N)\n  Z <- matrix(rep(NA,N*20),c(N,20))\n  Z.np <- matrix(rep(NA,N*20),c(N,20))\n  for(i in 1:N){\n    for(j in 1:20){\n      Z[ i, j] <- bias.gammas[ j ] +  X[i,]%*%gammas[j,]\n      Z.np[i,j] <-  (1) / (1+ exp(- Z[i,j]))\n    }\n    y.hat[i] <- bias.beta +Z.np[i,]%*%betas\n  }\n  return(y.hat)\n}\n\nreplicated_from_posterior_predictive <- function(X, chain){\n L <- 10000\n d <- dim(X)[1]\n y.rep <- matrix(rep(NA,L*d),nrow = L, ncol = d)\n for(i in 1:L){\n   betas <- c(chain$Beta.0[1,i,1], chain$Beta[,i,1])\n   gamma <- rbind((chain$Gamma.0[,i,1]),t(chain$Gamma[,,i,1]))\n   Z <- compute_Z_matrix(gamma,X)\n   mu_y <- Z%*%betas\n   sigma <- 1/sqrt(chain$tau[1,i,1])* diag(d)\n   y.rep[i] <- mvrnorm(mu = mu_y, Sigma = sigma)\n }\n return(y.rep)\n}\n\n\n",
    "created" : 1506252987848.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "106828502",
    "id" : "8490AC64",
    "lastKnownWriteTime" : 1506544080,
    "last_content_update" : 1506544080032,
    "path" : "C:/Users/Umbertojunior/Desktop/data science/Second Semestr/SDS 2/project/Bayesian Neural Network/neal_priors_for_BNN.R",
    "project_path" : "neal_priors_for_BNN.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}