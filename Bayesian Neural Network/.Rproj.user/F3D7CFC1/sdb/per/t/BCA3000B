{
    "collab_server" : "",
    "contents" : "require(rjags)\nrequire(coda)\nrequire(xtable)\n\n# loading data ------------------------------------------------------------\n\n#obs 1000\nload('data_simmulated_for_neal.RData')\nload('network_for_K_15_1000.RData')\n\n# muller rios chain\nM = 10000\n\nind <- read.csv(file = \"chain winbugs/muller_rois_index.txt\", sep = '\\t', header = F)\nc <- dim(index)[1]\nobj <- read.csv(file = \"chain winbugs/muller_rois_chain.txt\", sep = '\\t', header = F)\nchain_muller_Rios <- matrix(obj[,2], c(M,c))\n\n\n# looking to marginal distributions..\nl=c(1,16,23,18)\nindex <- ind[l,1]\ns1 <- chain_muller_Rios[,l[1]]\ns2 <- chain_muller_Rios[,l[2]]\ns3 <- chain_muller_Rios[,l[3]]\ns4 <- chain_muller_Rios[,l[4]]\n\n#save(s1,s2,s3,s4,index,ind,l,file = 'presentation/chains_for_muller_plot.RData')\n\nopt1 <- take_the_weight(ind[l[1],1])\nopt2 <- take_the_weight(ind[l[2],1])\nopt3 <- take_the_weight(ind[l[3],1])\nopt4 <- take_the_weight(ind[l[4],1])\n\npar(mfrow=c(2,2), mar=c(2.5,2.5,1.5,2.5))\nplot(density(s1), main = ind[l[1],1])\npoints(opt1,0, col='blue')\nplot(density(s2), main = ind[l[2],1])\npoints(opt2,0, col='blue')\nplot(density(s3), main = ind[l[3],1])\npoints(opt3,0, col='blue')\nplot(density(s4), main = ind[l[4],1])\npoints(opt3,0, col='blue')\nopt <- c(opt1,opt2,opt3,opt4)\np_val1 <- sum(s1<opt1)/length(s1)\np_val2 <- sum(s2<opt2)/length(s2)\np_val3 <- sum(s3<opt3)/length(s3)\np_val4 <- sum(s4<opt4)/length(s4)\np_val <- c(min(p_val1,1-p_val1),min(p_val2,1-p_val2),min(p_val3,1-p_val3),min(p_val4,1-p_val4))\ntable  <- cbind(rbind(HPDinterval(as.mcmc(s1)),HPDinterval(as.mcmc(s2)),\n                      HPDinterval(as.mcmc(s3)),HPDinterval(as.mcmc(s4))),opt,p_val)\nprint(xtable(table))\n\n# Trace plots\npar(mfrow=c(2,2), mar=c(2.5,2.5,1.5,2.5))\nts.plot(s1, main = ind[l[1],1])\nts.plot(s2, main = ind[l[2],1])\nts.plot(s3, main = ind[l[3],1])\nts.plot(s4, main = ind[l[4],1])\n\n\n# Running means\nts.plot(cumsum(s1)/seq_along(s1))\nts.plot(cumsum(sim)/seq_along(s2))\nts.plot(cumsum(sim)/seq_along(sim))\nts.plot(cumsum(sim)/seq_along(sim))\n\n# Auto-correlation functions\nacf(sim)\n\n# Cross-Corelation\nh <- 5      #1:106\nindex <- ind[h,1]\nindex\nsim2 <- chain_muller_Rios[,h]\nccf(sim, sim2,50)\n\n# Spectral Analysis with coda Geweke Convergence diagnostic\ns1 <- as.mcmc(s1)\nZ_score1 <- geweke.diag(s1)\np_v1 <- min(pnorm(Z_score1$z),1 - pnorm(Z_score1$z))\n\ns2 <- as.mcmc(s2)\nZ_score2 <- geweke.diag(s2)\np_v2 <- min(pnorm(Z_score2$z),1 - pnorm(Z_score2$z))\n\ns3 <- as.mcmc(s3)\nZ_score3 <- geweke.diag(s3)\np_v3 <- min(pnorm(Z_score3$z),1 - pnorm(Z_score3$z))\n\ns4 <- as.mcmc(s4)\nZ_score4 <- geweke.diag(s4)\np_v4 <- min(pnorm(Z_score4$z),1 - pnorm(Z_score4$z))\n\nZ_score <- c(Z_score1$z,Z_score2$z,Z_score3$z,Z_score4$z)\np_v <- c(p_v1,p_v2,p_v3,p_v4)\ns <- c('Beta1','Beta0','gamma 2,1','gamma 1,2')\ntable <- cbind(s,Z_score,p_v)\ncolnames(table) <- c('chain','Z_score','p_value')\nrow.names(table) <- 1:4\nprint(xtable(table))\n\n# Heidelberger and Welch Convergence diagnostic\nxtable(as.matrix(heidel.diag(s1)))\n\n# posterior prediction distribution\n#take l from 107 to 1106\nfor(obs in 1:10){\n  l= 106+ obs\n  pred_ind <- ind[l,1]\n  sim <- chain_muller_Rios[,l]\n  plot(density(sim), main = ind[l,1])\n  points(Y[obs],0, col = 'blue')\n  p_val <- sum(sim <=Y[obs])/length(sim)\n  p_val <- min(p_val, 1- p_val)\n  legend('topleft',legend = bquote(p-value ~ \"=\" ~ .(p_val)),lty = 1:2, cex = 0.5)\n  Sys.sleep(0.8)  \n}\n\n# visualizing the posterior log-likelihood\nl= 1107\npred_ind <- ind[1108:2107,1]\np.log <- rowSums(chain_muller_Rios[,pred_ind])\nts.plot(p.log)\n\n\n\n\n# visualizing distribution for neal ------------------------------------------------\nload('neal_chain3_for_15nuerons.RData')\nload('neal_chain4_for_15nuerons.RData')\nload('neal_chain_huge_chain.RData')\n\nK <- 15\nsim <- sim_neal_huge\nsim1 <- sim_neal3\nsim2 <- sim_neal4\n\nfor(k in 1:K){\n  plot_and_find_the_mode(sim$Gamma.0,k, obj='Gamma.0')\n  Sys.sleep(0.5)\n  for(p in 1:P){\n    plot_and_find_the_mode(sim$Gamma,k,p, obj='Gamma')\n    Sys.sleep(0.5)\n  }\n}\n\nplot_and_find_the_mode(sim$Beta.0, obj = 'Beta.0')\nfor(k in 1:K){\n  plot_and_find_the_mode(sim$Beta,k, obj = 'Beta')\n  Sys.sleep(0.5)\n}\n\nfor(i in 1:10){\n  plot(density(sim$Y.rep[i,,1]))\n  points(Y[i],0,col='blue')\n  p <- mean(sim$Y.rep[i,,1]< Y[i])\n  p_val <- min(p, 1-p)\n  print(p_val)\n  Sys.sleep(0.7)\n}\n\n# Traceplots\n\nts.plot(sim$Beta[1,,])\nts.plot(sim$Beta.0[1,,])\nts.plot(sim$Gamma.0[2,,])\nts.plot(sim$Gamma[1,1,,])\n\n\nts.plot(cbind(sim1$Beta[1,,],sim2$Beta[1,,]))\nts.plot(cbind(sim1$Beta.0[1,,],sim2$Beta.0[1,,]))\nts.plot(cbind(sim1$Gamma.0[2,,],sim2$Gamma.0[2,,]))\nts.plot(cbind(sim1$Gamma[1,1,,],sim2$Gamma[1,1,,]))\n\n\n\n# running mean\n\ns1 <- sim$Beta[1,,]\ns2 <- sim$Beta.0[1,,]\ns3 <- sim$Gamma.0[2,,]\ns4 <- sim$Gamma[1,1,,]\n\nts.plot(cumsum(s1)/seq_along(s1))\nts.plot(cumsum(s2)/seq_along(s2))\nts.plot(cumsum(s3)/seq_along(s3))\nts.plot(cumsum(s4)/seq_along(s4))\n\n# running means two chains\n\ns1_1 <- sim1$Beta[1,,]\ns1_2 <- sim1$Beta.0[1,,]\ns1_3 <- sim1$Beta[2,,]\ns1_4 <- sim1$Gamma[1,1,,]\n\ns2_1 <- sim2$Beta[1,,]\ns2_2 <- sim2$Beta.0[1,,]\ns2_3 <- sim2$Beta[2,,]\ns2_4 <- sim2$Gamma[1,1,,]\n\nts.plot(cbind(cumsum(s1_1)/seq_along(s1_1),cumsum(s2_1)/seq_along(s2_1)))\nts.plot(cbind(cumsum(s1_2)/seq_along(s1_2),cumsum(s2_2)/seq_along(s2_2)))\nts.plot(cbind(cumsum(s1_3)/seq_along(s1_3),cumsum(s2_3)/seq_along(s2_3)))\nts.plot(cbind(cumsum(s1_4)/seq_along(s1_4),cumsum(s2_4)/seq_along(s2_4)))\n\n# Auto-correlation functions\nacf(s1,lag.max = 10000)\nacf(s2,10000)\nacf(s3,10000)\nacf(s4,10000)\n\n\n# Cross-Corelation\nccf(s1, s2,10000)\nccf(s1, s3,10000)\nccf(s1, s4,10000)\n\n# Spectral Analysis with coda Geweke Convergence diagnostic\ns1 <- as.mcmc(s1)\nZ_score1 <- geweke.diag(s1)\np_v1 <- min(pnorm(Z_score1$z),1 - pnorm(Z_score1$z))\n\ns2 <- as.mcmc(s2)\nZ_score2 <- geweke.diag(s2)\np_v2 <- min(pnorm(Z_score2$z),1 - pnorm(Z_score2$z))\n\ns3 <- as.mcmc(s3)\nZ_score3 <- geweke.diag(s3)\np_v3 <- min(pnorm(Z_score3$z),1 - pnorm(Z_score3$z))\n\ns4 <- as.mcmc(s4)\nZ_score4 <- geweke.diag(s4)\np_v4 <- min(pnorm(Z_score4$z),1 - pnorm(Z_score4$z))\n\nZ_score <- c(Z_score1$z,Z_score2$z,Z_score3$z,Z_score4$z)\np_v <- c(p_v1,p_v2,p_v3,p_v4)\ns <- c('Beta1','Beta0','gamma 2,1','gamma 1,2')\ntable <- cbind(s,Z_score,p_v)\ncolnames(table) <- c('chain','Z_score','p_value')\nrow.names(table) <- 1:4\nprint(xtable(table,digit = 1))\n\n# Heidelberger and Welch Convergence diagnostic\nheidel.diag(s)\n\n# posterior prediction distribution\n#take l from 107 to 1106\nfor(obs in 1:10){\n  l= 106+ obs\n  pred_ind <- ind[l,1]\n  s <- sim$Y.rep[obs,,1]\n  plot(density(s), main = ind[l,1])\n  points(Y[obs],0, col = 'blue')\n  p_val <- sum(s <=Y[obs])/length(s)\n  p_val <- min(p_val, 1- p_val)\n  legend('topleft',legend = bquote(p-value ~ \"=\" ~ .(p_val)),lty = 1:2, cex = 0.5)\n  Sys.sleep(0.8)  \n}\n\n# visualizing the posterior log-likelihood\npred_ind <- ind[1108:2107,1]\np.log <- colSums(sim$p.log[,,1])\nts.plot(p.log)\n\n\n\n# third case conjugate pror mixed with flat prior -------------------------\nload('chain_conjugate_BNN.RData')\nload('chain_conjugate_BNN_2.RData')\n\nsim <- c3$chain\nsim1 <- c2\nindex <- colnames(sim)\n# choose l from 1 to 127\nl= 12; index[l]\nopt <- take_the_weight(index[l]);opt\nplot(density(sim[,l]), main = index[l])\npoints(opt,0, col='blue')\nHPDinterval(as.mcmc(sim[,l]))\np_v <- sum(sim[,l]<opt)/length(sim[,l])\nprint(list('p-value'= min(p_v, 1-p_v)))\n\n#marginal sigma\nl= 128; index[l]\nplot(density(sim[,l]), main = index[l])\nHPDinterval(as.mcmc(sim[,l]))\n\n# Traceplots\ns1 <- sim$`Beta 1`\ns2 <- sim$`Beta 0`\ns3 <- sim$`Gamma 2.1`\ns4 <- sim$`Gamma 1.2`\n\n\npar(mfrow=c(2,2), mar=c(2.5,2.5,1.5,2.5))\nts.plot(s1,main= 'Beta 1')\nts.plot(s2,main= 'Beta 0')\nts.plot(s3,main= 'Gamma.0 2')\nts.plot(s4,main= 'Gamma 1.1')\n\ns1_1 <- s1\ns1_2 <- s2\ns1_3 <- s3\ns1_4 <- s4\n\ns2_1 <- sim1$`Beta 1`\ns2_2 <- sim1$`Beta 0`\ns2_3 <- sim1$`Gamma 2.1`\ns2_4 <- sim1$`Gamma 1.2`\n\nts.plot(cbind(s1_1,s2_1),main= 'Beta 1')\nts.plot(cbind(s1_2,s2_2),main= 'Beta 0')\nts.plot(cbind(s1_3,s2_3),main= 'Gamma.0 2')\nts.plot(cbind(s1_4,s2_4),main= 'Gamma 1.1')\n\n\n# running mean\n\npar(mfrow=c(2,2), mar=c(2.5,2.5,1.5,2.5))\nts.plot(cumsum(s1)/seq_along(s1),main= 'Beta 1')\nts.plot(cumsum(s2)/seq_along(s2),main= 'Beta 0')\nts.plot(cumsum(s3)/seq_along(s3),main= 'Gamma.0 2')\nts.plot(cumsum(s4)/seq_along(s4),main= 'Gamma 1.1')\n\n# running means two chains\n\nts.plot(cbind(cumsum(s1_1)/seq_along(s1_1),cumsum(s2_1)/seq_along(s2_1)))\nts.plot(cbind(cumsum(s1_2)/seq_along(s1_2),cumsum(s2_2)/seq_along(s2_2)))\nts.plot(cbind(cumsum(s1_3)/seq_along(s1_3),cumsum(s2_3)/seq_along(s2_3)))\nts.plot(cbind(cumsum(s1_4)/seq_along(s1_4),cumsum(s2_4)/seq_along(s2_4)))\n\n# Auto-correlation functions\nacf(s1,lag.max = 10000)\nacf(s2,10000)\nacf(s3,10000)\nacf(s4,10000)\n\n\n# Cross-Corelation\nccf(s1, s2,10000)\nccf(s1, s3,10000)\nccf(s1, s4,10000)\n\n# Spectral Analysis with coda Geweke Convergence diagnostic\ns <- as.mcmc(s1)\nZ_score <- geweke.diag(s);Z_score\nmin(pnorm(Z_score$z),1 - pnorm(Z_score$z))\n\n# Heidelberger and Welch Convergence diagnostic\nheidel.diag(s)\n\nc3$deviance\n\n# functions ---------------------------------------------------------------\n\ntake_the_weight <- function(index){\n  dim <- length(index)\n  for(i in 1:dim){\n    i <- as.character(index[i])\n    if(length(grep('Beta.0', i))){\n      val <- net.1$weights[[1]][[2]][1]\n      i <-''\n    }\n    if(length(grep(\"Beta\", i))){\n      v <- as.numeric(gsub(\".*([0-9]+).*$\", \"\\\\1\", index))\n      val <- net.1$weights[[1]][[2]][1+v]\n      i <-''\n    }\n    if(length(grep('Gamma.0', i))){\n      v <- as.numeric(gsub(\".*([0-9]+).*$\", \"\\\\1\", index))\n      val <- net.1$weights[[1]][[1]][1,v]\n      i <-''\n    }\n    if(length(grep(\"Gamma\", i))){\n      v <- as.numeric(unlist(strsplit(gsub(\".*([0-9]+,[0-9]+).*$\", \"\\\\1\", index),',')))\n      val <- net.1$weights[[1]][[1]][v[2],v[1]]\n      i <-''\n    }\n  }\n  return(val)\n}\n\n# # Make predictions\n# \n# y.hat.mode.2 <- prediction_for_neal_BNN(X,sim = sim)\n# y.hat.mean.2 <- prediction_for_neal_BNN_with_mean(X,sim)\n# \n# plot(Y,y.hat,xlim = c(-4,5),ylim = c(0,4))\n# plot(Y,y.hat.mean.2)\n# plot(Y,y.hat.mode.2)\n",
    "created" : 1506411240752.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1982561664",
    "id" : "BCA3000B",
    "lastKnownWriteTime" : 1506772941,
    "last_content_update" : 1506772941509,
    "path" : "C:/Users/Umbertojunior/Desktop/data science/Second Semestr/SDS 2/hw 2/hw_2/viasualization_of_problems.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}